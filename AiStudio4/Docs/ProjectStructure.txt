This application is a full‐featured, React/TypeScript–based chat and AI tool management system built using modern libraries such as Zustand (for state management), Axios (for API calls), and WebSockets (for real-time communications). It is architected in a modular way using a “feature–driven” file structure with clearly separated concerns. In what follows we describe its overall architecture and data flows, then list and explain the purpose and interconnection of every major file or group of files.

─────────────────────────────

OVERVIEW
─────────────────────────────
• The app provides an interactive chat workspace where users can converse with AI models.
• It supports features to manage system prompts (with associated tools, user prompts, and models), user prompts (with shortcuts for slash commands), configure appearance (font size, and an AI-driven theming engine), and manage external “tools” (custom functions or templates, including MCP servers).
• It supports real–time updates via WebSocket connections (for streaming message tokens, conversation updates, file system changes, and status messages).
• It uses a command–based interface that lets the user invoke actions via keyboard shortcuts or a command palette; commands are registered in dedicated “commands” files and managed by a command registry service.
• The UI is split into several pane areas (chat area, sidebar, settings modals, tools modal, etc.) that are arranged and managed by a panel–management system (using react–resizable–panels) coordinated via a dedicated PanelStore.
• It includes a robust attachment system for images, PDFs, and text files, with features like drag-and-drop and clipboard image pasting.
• A search functionality allows users to find specific messages across their conversation history.
• A unified modal system manages all dialogs and pop-ups.
─────────────────────────────
2. PROJECT STRUCTURE
─────────────────────────────
The source code is organized into several folders that separate the types, services, UI components, custom hooks, state stores, commands, and utilities. Here is an overview:

A. types/
 • attachment.ts – Defines the `Attachment` interface for handling file attachments, including metadata and preview URLs.
 • conv.ts – Defines the `Message` and `Conv` interfaces (and related token/cost fields) that form the building blocks of conversation data.
 • modelTypes.ts – Declares a simple type alias (`ModelType`) for distinguishing primary versus secondary models.
 • settings.ts – Contains type definitions for `ServiceProvider` and `Model`, including pricing, color, reasoning effort, and TTS preferences.
 • systemPrompt.ts – Specifies the structure for system prompts (`SystemPrompt`) and a related `SystemPromptFormValues` interface for editing.
 • theme.ts – Defines the `Theme` interface, including properties for theme JSON, preview colors, and font CDN URLs.
 • toolTypes.ts – Defines types for `Tool` and `ToolCategory`, including schema, filetype, and extra properties.
 • ui.ts – Declares UI–related types (e.g., `PanelPosition`, `PanelState`) for panel management.
 • userPrompt.ts – Defines the `UserPrompt` and `UserPromptFormValues` interfaces, including shortcuts for slash commands.
 • websocket.ts – Defines the shape of the WebSocket state object (`WebSocketState`).

B. services/
 1. api/
  • apiClient.ts – Configures the Axios instance for making HTTP requests to the backend. It sets common headers (including adding the client ID from WebSocketService) and global request/response interceptors for error logging.
 2. providers/
  • fileNameProvider.ts – Implements `SlashItemProvider` to provide project file names as slash command suggestions.
  • userPromptProvider.ts – Implements `SlashItemProvider` to provide user prompts as slash command suggestions.
 3. websocket/
  • websocketEvents.ts – Provides helper functions (`dispatchWebSocketEvent`, `listenToWebSocketEvent`) to dispatch and listen for WebSocket custom events (such as connection status, stream tokens, new conversation messages, file system changes, etc.).
  • WebSocketService.ts – Implements the WebSocket connection manager (`webSocketService`). It handles connecting to the server (including auto–reconnection strategies), sending JSON messages, interpreting incoming messages (dispatching them via the event system), and maintaining local status (e.g. clientId, connection status).
 • commandRegistry.ts – Provides a centralized service for registering, unregistering, searching, and executing application commands.
 • slashItemRegistry.ts – Manages providers for slash command suggestions (e.g., user prompts, file names) and caches/filters these items.
 • windowEvents.ts – Defines a registry of global window events (`WindowEvents`) and provides a service (`windowEventService`) for emitting and listening to these events, used for cross-component communication not directly handled by state stores.

C. components/
This folder is very large and subdivided by feature.

 • commands/
  – CommandInitializer.tsx – At application start–up, this component initializes and registers core application commands (and more), by calling various “initialize” functions from the `src/commands/` directory.
 • common/
  – GenericForm.tsx – A reusable, dynamic form component that renders form fields based on provided definitions. Used by settings forms, tool editor, etc.
 • ConvTreeView/ (subfolder)
  – ConvTreeView.tsx – Uses D3.js to render a hierarchical tree view of conversation messages. Includes `useMessageTree.ts` to convert flat message arrays to tree data, and `useTreeVisualization.ts` for the D3 rendering logic. Also includes `EmptyTreeView.tsx` and `TreeControls.tsx`.
 • ConvView/ (subfolder)
  – ConvView.tsx – Renders the main conversation messages in markdown using the MarkdownPane component; it also displays real–time streaming tokens. Includes `MessageItem.tsx`, `MessageActions.tsx`, `MessageEditor.tsx`, `MessageMetadata.tsx`, `StreamingMessage.tsx`, and `ScrollToBottomButton.tsx`.
 • diagrams/
  – codeBlockRendererRegistry.ts – Implements a registry for “code block renderers.” The registry associates a set of languages (like mermaid, JSON, HTML, dot, txt, codediff) with their corresponding renderer components.
  – mermaid-renderer.tsx, json-renderer.tsx, html-renderer.tsx, dot-renderer.tsx, txt-renderer.tsx, codeDiff-renderer.tsx, and types.ts – Implement renderers for specialized content.
 • InputBar/ (subfolder)
  – InputBar.tsx – The main input component at the bottom of the screen. Composed of `SystemPromptSection.tsx`, `MessageInputArea.tsx`, `AttachmentSection.tsx`, `ActionButtons.tsx`, `ToolsSection.tsx`, `ModelStatusSection.tsx`, `StatusSection.tsx`, and `TemperatureControl.tsx`.
 • MarkdownPane/ (subfolder)
  – MarkdownPane.tsx – Renders markdown content using ReactMarkdown and SyntaxHighlighter. Manages code block collapsing and raw/rendered view toggling. Includes `CodeBlock.tsx` and `CodeBlockHeader.tsx`.
 • modals/ (subfolder)
  – ModalManager.tsx – Central component for rendering all modals based on `useModalStore` state.
  – Specific modal components: `AppearanceModal.tsx`, `ConfirmationModal.tsx`, `FormModal.tsx`, `ModelsModal.tsx`, `ProvidersModal.tsx`, `ServerModal.tsx`, `SystemPromptModal.tsx`, `ThemeModal.tsx`, `ToolEditorModal.tsx`, `ToolModal.tsx`, `UserPromptModal.tsx`. These wrap their respective library/editor components.
 • navigation/
  – NavigationContainer.tsx – The high–level component controlling overall layout. Integrates with `PanelManager.tsx` and `PanelContainerLayout.tsx`.
 • servers/ (subfolder)
  – DeleteServerDialog.tsx – Confirmation dialog for deleting MCP servers.
  – ServerDialog.tsx – Bridge component for legacy event handling to open the `ServerModal`.
  – ServerForm.tsx – Form for adding/editing MCP server definitions.
  – ServerFormDialog.tsx – Dialog wrapper for `ServerForm`.
 • settings/ (subfolder)
  – AppearanceTab.tsx and FontSizeControl.tsx: UI for appearance settings (font size, theme management).
  – ModelForm.tsx and ModelManagement.tsx: Components to display, add, edit, and delete AI model configurations.
  – ServiceProviderForm.tsx and ServiceProviderManagement.tsx: Similar functionality for managing service provider settings.
  – ThemeForm.tsx and ThemeManagement.tsx: UI for creating, editing, and managing themes.
  – IconSelector.tsx: A component for selecting icons (used in PinnedShortcuts rename and ServiceProviderForm).
 • SystemPrompt/ (subfolder)
  – SystemPromptCard.tsx – Displays an individual system prompt in a card view.
  – SystemPromptComponent.tsx – Displays the active system prompt in the InputBar, with an expandable/editable portal.
  – SystemPromptEditor.tsx – A form for editing or creating system prompts.
  – SystemPromptLibrary.tsx – UI for browsing, searching, and managing system prompts.
  – SystemPromptCollapsedDisplay.tsx and SystemPromptPortal.tsx: Helper components for `SystemPromptComponent`.
 • tools/ (subfolder)
  – ToolDialog.tsx – Bridge component for legacy event handling to open the `ToolModal`.
  – ToolEditor.tsx – A form for editing or creating a tool definition.
  – ToolPanel.tsx – Displays available tools and allows users to toggle tool activation.
 • ui/ (subfolder) - Contains shadcn/ui components and custom UI elements.
  – unified-modal-dialog/ (subfolder): Implements the `UnifiedModalDialog` system with header, content, footer, context, types, and variants.
 • UserPrompt/ (subfolder)
  – UserPromptCard.tsx, UserPromptEditor.tsx, UserPromptLibrary.tsx: Similar to SystemPrompt components, but for user prompts.
 • AttachmentPreview.tsx, AudioAttachment.tsx, ChatContainer.tsx, ChatSpace.tsx, CommandBar.tsx, DragDropZone.tsx, FileAttachment.tsx, FontSizeProvider.tsx, HistoricalConvTree.tsx, HistoricalConvTreeList.tsx, LiveStreamToken.tsx, LoadingTimer.tsx, MessageAttachments.tsx, ModelStatusBar.tsx, PanelContainerLayout.tsx, PanelManager.tsx, PinnedShortcutButton.tsx, PinnedShortcutDropdown.tsx, PinnedShortcutRow.tsx, PinnedShortcuts.tsx, RenameShortcutDialog.tsx, Sidebar.tsx, SlashDropdown.tsx, StatusMessage.tsx: Various UI layout and chat flow components with specific responsibilities.

D. hooks/
Custom hooks abstract many behaviors and resources:
 • use-media-query.ts – A hook that returns whether a given CSS media query matches.
 • use-toast.ts – Hook for managing and displaying toast notifications.
 • useAppearanceManagement.ts – Wraps the Appearance store functionality and exposes functions for managing appearance settings.
 • useAttachmentManager.ts – Manages the state and logic for handling file attachments, including validation and processing.
 • useChatManagement.ts – Manages chat operations (sending messages, fetching configuration, setting models, loading conversations) by wrapping API calls and interfacing with the ConvStore.
 • useConfirmationDialog.ts – Hook to programmatically show a confirmation dialog.
 • useDragDrop.ts – A helper hook for integrating react-beautiful-dnd.
 • useFileSystemManagement.ts – Hook for managing file system data fetched from the server.
 • useFormDialog.ts – Hook to programmatically show a form dialog.
 • useMessageGraph.ts – Wraps construction of a `MessageGraph` that turns flat message arrays into a graph structure.
 • useResourceFactory.ts – A factory that builds generic resource hooks for CRUD operations.
 • useResourceManagement.ts – Combines resource hooks for models, system prompts, user prompts, and providers into higher-level management hooks.
 • useStreamTokens.ts – Listens for streaming tokens from WebSocket events and accumulates them.
 • useSystemPromptSelection.ts – Hook for selecting system prompts and handling associated side effects (activating tools, user prompts, models).
 • useToolCommands.ts – Connects the tools system with the command registry.
 • useToolsManagement.ts – Provides resource operations and helper functions for tools and tool categories.
 • useUserPromptManagement.ts – Provides resource operations and helper functions for user prompts.
 • useVoiceInput.tsx – Wraps the browser’s Web Speech API for voice input.
 • useWebSocket.ts – Hook that abstracts WebSocket connectivity, providing status and send/subscribe methods.

E. stores/
The application uses Zustand to hold local state in many domains:
 • useAppearanceStore.ts – Holds visual appearance preferences (font size) and handles saving/loading these settings.
 • useAttachmentStore.ts – Manages staged attachments in the input bar and attachments associated with specific message IDs.
 • useCommandStore.ts – The central registry for application commands.
 • useConvStore.ts – Stores conversation data, active conversation, selected message, and provides methods to manage messages and conversations.
 • useFileSystemStore.ts – Holds the file system state (directories and files) received from the server.
 • useGeneralSettingsStore.ts – Manages general application settings like temperature and cost tracking.
 • useHistoricalConvsStore.ts – Maintains a list of historical conversations and provides methods to fetch conversation trees.
 • useJumpToEndStore.ts – Manages the "Jump to End" (auto-scroll) preference for the chat view.
 • useMcpServerStore.ts – Manages MCP server definitions, their enabled state, and associated tools.
 • useModalStore.ts – Manages the state of all modals in the application (which modal is open and its props).
 • useModelStore.ts – Maintains the list of available AI models, service providers, and selected primary/secondary models.
 • usePanelStore.ts – Manages panel states (sidebar, etc.) including open/closed, collapsed, sizes, and positions.
 • usePinnedCommandsStore.ts – Stores commands pinned by the user for quick access.
 • useSearchStore.ts – Manages search term, search results, search status, and highlighted messages.
 • useStatusMessageStore.ts – Manages the display of status messages to the user.
 • useSystemPromptStore.ts – Holds the list of system prompts, default prompt ID, conversation-specific prompts, and current prompt.
 • useThemeStore.ts – Manages available UI themes and the active theme ID.
 • useToolStore.ts – Holds the list of available tools, tool categories, and active tools.
 • useVoiceInputStore.ts – Manages the state of voice input (listening status, errors).

F. commands/
The command system allows users to perform actions via shortcuts or the command palette:
 • appearanceCommands.ts – Registers commands for appearance settings (font size, theme library).
 • coreCommands.ts – Registers core commands (new conversation, exit application, toggle UI panels).
 • mcpServerCommands.ts – Registers commands for managing and toggling MCP servers.
 • modelCommands.ts – Dynamically generates commands for choosing primary/secondary AI models.
 • settingsCommands.ts – Registers commands to open settings modals (models, providers, appearance).
 • shortcutPromptExecutor.ts – Utility to handle prompt shortcuts (slash commands) from the command bar input (though primary slash command handling is in InputBar).
 • systemPromptCommands.ts – Registers commands for system prompt library and dynamically registers individual system prompts.
 • themeCommands.ts – Dynamically registers commands for selecting themes.
 • toolCommands.ts – Registers commands for tool library and dynamically registers individual tools.
 • types.ts – Defines common types for commands (`Command`, `CommandGroup`, `CommandSection`).
 • userPromptCommands.ts – Registers commands for user prompt library and dynamically registers individual user prompts.
 • voiceInputCommand.ts – Registers the voice input command.

G. utils/
General utilities help abstract common behavior:
 • apiUtils.ts – Contains `normalizeError` and `createApiRequest` for consistent API call handling, and `useApiCallState` hook for managing loading/error states.
 • attachmentUtils.ts – Utilities for handling file attachments (validation, preview URL creation, text extraction, Base64 conversion, formatting text attachments).
 • debugUtils.ts – Initializes debug utilities for console access (e.g., `window.addRandomMessages`).
 • hookUtils.ts – Provides `useInitialization` and `useInitializeIfEmpty` hooks.
 • messageGraph.ts – Implements a `MessageGraph` class for building a parent–child graph from flat message arrays.
 • modelUtils.ts – Utilities for working with models, like `getModelFriendlyName`.
 • promptUtils.ts – Exposes global window functions (`appendToPrompt`, `getPromptText`, `setPrompt`) for manipulating the input bar text.
 • textAreaUtils.ts – Utility to get cursor position in a textarea (`getCursorPosition`).
 • webSocketUtils.ts – Provides `handleWebSocketMessage` for processing incoming WebSocket messages (like file system updates) and hooks (`useWebSocketEvent`, `useWebSocketStatus`, `useStreamableWebSocketData`) for managing WebSocket events.

H. lib/
 • ThemeManager.ts – Centralized theming system that discovers themeable component properties, applies themes by injecting CSS variables, and handles font CDN loading.
 • utils.ts – Contains the `cn` utility for combining class names (using clsx and tailwind-merge).

I. Main entry points
 • index.css – Main stylesheet (Tailwind CSS directives, custom component styles, utility classes).
 • main.tsx – Entry point that renders the `App` component. Initializes ThemeManager, loads default system prompt/tools, and fetches general settings.
 • App.tsx – Root component. Wraps the application in `FontSizeProvider`, initializes commands via `CommandInitializer`, and renders `NavigationContainer` with `ChatSpace`. Connects to WebSocket service and initializes slash command providers. Includes `ModalManager` for centralized modal handling.
 • CommandInitializationPlugin.tsx – Plugin component that handles dynamic registration of commands based on store changes (e.g., system prompts, user prompts, models, tools, themes, MCP servers). Also handles applying default system prompt tools and associated user prompts for new conversations.

─────────────────────────────
3. MAJOR DATA FLOWS AND FUNCTIONALITY
─────────────────────────────

A. Chat and Conversation Flow
 • Incoming chat messages are received via WebSocket managed by `WebSocketService`.
 • Received messages are dispatched using `websocketEvents` and processed by `useConvStore` (via listeners in the store itself) in response to “conv:upd” or “conv:load” events. Attachments in messages are processed by `processAttachments` to convert Base64 content to ArrayBuffers and generate preview URLs.
 • `ConvStore` maintains conversations. `ChatSpace` reads the current conversation.
 • `ChatContainer` wraps `ConvView`. `ConvView` renders messages using `MarkdownPane` and `LiveStreamToken`. The `useJumpToEndStore` and `ScrollToBottomButton` manage auto-scrolling.
 • User input is handled by `InputBar`, which uses `useChatManagement` to send messages. Attachments are managed by `useAttachmentStore` and `AttachmentPreviewBar`.
 • Interjections during tool loops are possible via Ctrl+Enter or a dedicated button, handled by `InterjectionService` on the backend.

B. Appearance and Theming
 • Appearance settings (font size) are handled by `useAppearanceStore`. `FontSizeProvider` applies font size globally.
 • Theming is managed by `ThemeManager.ts` and `useThemeStore`. Themes can be created (even by AI using a special tool), managed, and applied via the `ThemeModal` and `ThemeManagement` components. `ThemeManager` injects CSS variables and loads fonts from CDNs.

C. Models, Service Providers, MCP Servers (Settings & Management)
 • `Model`, `ServiceProvider` types are in `settings.ts`. UI is in `settings/` (e.g., `ModelManagement`) and `modals/` (`ModelsModal`, `ProvidersModal`).
 • Resource hooks (`useResourceManagement`) and `useModelStore` manage models/providers.
 • MCP servers are defined by `McpServerDefinition` in `useMcpServerStore`. UI is in `servers/` and `modals/ServerModal.tsx`. `mcpServerCommands.ts` handles command registration.

D. System Prompts & User Prompts
 • Managed by `useSystemPromptStore`, `useUserPromptStore`, and `useSystemPromptManagement`, `useUserPromptManagement` hooks.
 • UI in `SystemPrompt/`, `UserPrompt/` folders and corresponding modals.
 • System prompts can be associated with tools, user prompts, MCP servers, and primary/secondary models, which are automatically activated/selected when the system prompt is applied. `useSystemPromptSelection` hook centralizes this logic.
 • User prompts can have shortcuts for quick insertion via slash commands in `InputBar`.

E. Tools
 • Managed by `useToolStore` and `useToolsManagement`. UI in `tools/` and `ToolModal`.
 • `toolCommands.ts` integrates tools with the command system.
 • Built-in tools have `ExtraProperties` configurable via the UI (though the UI for this part is still in design).

F. Command System & Pinned Shortcuts
 • `commandRegistry.ts` and `useCommandStore` manage commands. `CommandInitializer` and `CommandInitializationPlugin` register static and dynamic commands.
 • `CommandBar` provides search and execution.
 • `PinnedShortcuts` (with `PinnedShortcutButton`, `PinnedShortcutRow`, `PinnedShortcutDropdown`, `RenameShortcutDialog`) allows users to pin and manage frequently used commands. `usePinnedCommandsStore` handles their state.

G. Panels and Layout
 • `NavigationContainer` uses `PanelManager` and `PanelContainerLayout`. `usePanelStore` manages panel states (sidebar, modals as panels if designed that way).
 • The `Sidebar` component is a key panel, showing historical conversations (`HistoricalConvTreeList`) and the current conversation's structure (`ConvTreeView`). It also includes search functionality (`useSearchStore`).

H. WebSockets, API Integration, and Other Services
 • `apiClient.ts` and `apiUtils.ts` standardize HTTP calls.
 • `WebSocketService` and `websocketEvents.ts` manage real-time communication.
 • `windowEvents.ts` provides a decoupled way for components/services to communicate.
 • `slashItemRegistry.ts` manages slash command suggestions from providers like `fileNameProvider.ts` (using `useFileSystemStore`) and `userPromptProvider.ts`.

I. File System Interaction
 • `useFileSystemStore` holds the project's file structure.
 • `ProjectFileWatcherService` (backend) sends updates via WebSockets, handled by `websocketUtils.ts` on the client.
 • `useFileSystemManagement` hook provides access to this data.

─────────────────────────────
4. FILES & HOW THEY LINK
─────────────────────────────

Below is a non–exhaustive list of files (organized by directory) with brief notes on what they do and how they interact with others:

▸ src/types/
 – attachment.ts: Defines `Attachment` interface for file uploads. Used by attachment-related components, stores, and utilities.
 – conv.ts: Defines `Message` and `Conv` interfaces. Used by `useConvStore`, `ConvView`, `ConvTreeView`.
 – modelTypes.ts: Defines `ModelType` ('primary' | 'secondary'). Used by `useModelStore` and model selection commands.
 – settings.ts: Interfaces for `ServiceProvider` and `Model`. Used by `settings/` components, `useModelStore`.
 – systemPrompt.ts: `SystemPrompt` and `SystemPromptFormValues` interfaces. Used by `SystemPrompt/` components, `useSystemPromptStore`.
 – theme.ts: `Theme` interface. Used by `ThemeManager.ts`, `useThemeStore`, and theme-related UI components.
 – toolTypes.ts: `Tool` and `ToolCategory` interfaces. Used by `tools/` components, `useToolStore`.
 – ui.ts: `PanelState`, `PanelPosition`. Used by `PanelManager.tsx`, `PanelContainerLayout.tsx`, `usePanelStore`.
 – userPrompt.ts: `UserPrompt` and `UserPromptFormValues` interfaces. Used by `UserPrompt/` components, `useUserPromptStore`.
 – websocket.ts: `WebSocketState` interface. Used by `useWebSocketStore`.

▸ src/services/
  ▸ api/
   – apiClient.ts: Configures Axios client, used by `apiUtils.ts` and resource hooks.
  ▸ providers/
   – fileNameProvider.ts: Provides project file names for slash commands, using `useFileSystemStore`.
   – userPromptProvider.ts: Provides user prompts for slash commands, using `useUserPromptStore`.
  ▸ websocket/
   – websocketEvents.ts: `dispatchWebSocketEvent`, `listenToWebSocketEvent` for decoupled WebSocket event handling.
   – WebSocketService.ts: Manages WebSocket connection, sends/receives messages, dispatches events.
  – commandRegistry.ts: Central service for command management, abstracting `useCommandStore`.
  – slashItemRegistry.ts: Service for managing and providing slash command suggestions.
  – windowEvents.ts: Defines global `WindowEvents` and `windowEventService` for emitting/listening to custom window events.

▸ src/components/
 • settings/ (AppearanceTab.tsx, FontSizeControl.tsx, ModelForm.tsx, ModelManagement.tsx, ServiceProviderForm.tsx, ServiceProviderManagement.tsx, ThemeForm.tsx, ThemeManagement.tsx, IconSelector.tsx):
  – UIs for managing various application settings. Use `GenericForm.tsx`, resource hooks (`useResourceManagement`), and respective Zustand stores. `IconSelector` is used for choosing icons.
 • diagrams/ (codeBlockRendererRegistry.ts, various *-renderer.tsx files, types.ts):
  – Renders specialized code blocks (Mermaid, JSON, HTML, DOT, TXT, CodeDiff) in `MarkdownPane`.
 • navigation/ (NavigationContainer.tsx):
  – Organizes main layout using `PanelManager` and `PanelContainerLayout`, integrating with `usePanelStore`.
 • SystemPrompt/ (SystemPromptCard.tsx, SystemPromptComponent.tsx, SystemPromptEditor.tsx, SystemPromptLibrary.tsx, SystemPromptCollapsedDisplay.tsx, SystemPromptPortal.tsx):
  – UI for system prompt management. `SystemPromptComponent` is interactive in the `InputBar`.
 • UserPrompt/ (UserPromptCard.tsx, UserPromptEditor.tsx, UserPromptLibrary.tsx):
  – UI for user prompt management.
 • common/ (GenericForm.tsx):
  – Reusable form builder using react-hook-form.
 • commands/ (CommandInitializer.tsx):
  – Initializes static commands at startup using functions from `src/commands/`.
 • tools/ (ToolDialog.tsx, ToolEditor.tsx, ToolPanel.tsx):
  – UI for managing and editing tools. `ToolDialog` is a bridge for opening `ToolModal`.
 • modals/ (ModalManager.tsx, various *-Modal.tsx files):
  – Centralized modal rendering. Specific modals wrap their respective library/editor UIs.
 • servers/ (DeleteServerDialog.tsx, ServerDialog.tsx, ServerForm.tsx, ServerFormDialog.tsx):
  – UI for MCP server management. `ServerDialog` is a bridge for opening `ServerModal`.
 • ui/ (various shadcn components, unified-modal-dialog/):
  – Base UI elements and the unified modal system.
  • InputBar/ (InputBar.tsx and its subcomponents):
   – The main user input area, composed of sections for system prompts, message input, attachments, actions, tools, model status, and temperature.
  • ConvView/ (ConvView.tsx and its subcomponents):
   – Renders the conversation messages, handles streaming, and includes actions/metadata for messages.
  • ConvTreeView/ (ConvTreeView.tsx and its subcomponents):
   – Renders the D3-based conversation tree.
  • MarkdownPane/ (MarkdownPane.tsx and its subcomponents):
   – Renders markdown content with syntax highlighting and diagram support.
  • AppHeader.tsx: Header bar with `CommandBar`, `PinnedShortcuts`, `ModelStatusBar`.
  • AttachmentPreview.tsx, AudioAttachment.tsx, DragDropZone.tsx, MessageAttachments.tsx: Components for handling and displaying file attachments.
  • ChatContainer.tsx, ChatSpace.tsx: Layout components for the chat interface.
  • CommandBar.tsx: Command palette UI.
  • FontSizeProvider.tsx: Applies global font size.
  • HistoricalConvTree.tsx, HistoricalConvTreeList.tsx: Display historical conversations in the sidebar.
  • LiveStreamToken.tsx: Renders individual streaming tokens (though `StreamingMessage.tsx` might render them as a single string now).
  • LoadingTimer.tsx: Visual loading indicator.
  • ModelStatusBar.tsx: Displays selected primary/secondary models.
  • PanelContainerLayout.tsx, PanelManager.tsx: Manage resizable UI panels.
  • PinnedShortcuts.tsx (and related PinnedShortcut* components): UI for pinned command shortcuts.
  • RenameShortcutDialog.tsx: Dialog for renaming pinned shortcuts.
  • Sidebar.tsx: Left sidebar with conversation history, search, and current conversation tree.
  • SlashDropdown.tsx: Dropdown for slash command suggestions.
  • StatusMessage.tsx: Displays status messages.

▸ src/hooks/
  – use-media-query.ts: Detects viewport size.
  – use-toast.ts: Manages toast notifications (likely from shadcn/ui).
  – useAppearanceManagement.ts: Manages appearance settings.
  – useAttachmentManager.ts: Logic for handling file attachments.
  – useChatManagement.ts: Logic for chat operations.
  – useConfirmationDialog.ts: Shows confirmation modals.
  – useDragDrop.ts: For react-beautiful-dnd integration.
  – useFileSystemManagement.ts: Accesses file system data.
  – useFormDialog.ts: Shows form modals.
  – useMessageGraph.ts: Creates a graph from messages.
  – useResourceFactory.ts: Generic hook for CRUD operations.
  – useResourceManagement.ts: Combines resource hooks for settings.
  – useStreamTokens.ts: Accumulates streaming tokens from WebSockets.
  – useSystemPromptSelection.ts: Handles logic for selecting system prompts and their associated actions.
  – useToolCommands.ts: Integrates tools with the command system.
  – useToolsManagement.ts: Manages tools and tool categories.
  – useUserPromptManagement.ts: Manages user prompts.
  – useVoiceInput.tsx: Wraps Web Speech API.
  – useWebSocket.ts: Abstracts WebSocket connectivity.

▸ src/stores/
  – useAppearanceStore.ts: Font size and appearance settings.
  – useAttachmentStore.ts: Manages staged and message-associated attachments.
  – useCommandStore.ts: Central command registry.
  – useConvStore.ts: Current conversation data.
  – useFileSystemStore.ts: Project file system structure.
  – useGeneralSettingsStore.ts: General app settings like temperature.
  – useHistoricalConvsStore.ts: Historical conversation summaries.
  – useJumpToEndStore.ts: "Jump to End" preference for chat view.
  – useMcpServerStore.ts: MCP server definitions and state.
  – useModalStore.ts: State for all modals.
  – useModelStore.ts: AI models and service providers.
  – usePanelStore.ts: UI panel states.
  – usePinnedCommandsStore.ts: Pinned command shortcuts.
  – useSearchStore.ts: Conversation search state.
  – useStatusMessageStore.ts: Status message display.
  – useSystemPromptStore.ts: System prompts.
  – useThemeStore.ts: UI themes.
  – useToolStore.ts: Tools and tool categories.
  – useVoiceInputStore.ts: Voice input state.

▸ src/commands/
  – appearanceCommands.ts, coreCommands.ts, mcpServerCommands.ts, modelCommands.ts, settingsCommands.ts, systemPromptCommands.ts, themeCommands.ts, toolCommands.ts, types.ts, userPromptCommands.ts, voiceInputCommand.ts: Define and register application commands using `commandRegistry.ts`.
  – shortcutPromptExecutor.ts: Helper for slash command-like execution from command bar (less used now with `SlashDropdown`).

▸ src/utils/
  – apiUtils.ts: `normalizeError`, `createApiRequest`, `useApiCallState`.
  – attachmentUtils.ts: File attachment helpers.
  – debugUtils.ts: Console debug utilities.
  – hookUtils.ts: `useInitialization`, `useInitializeIfEmpty`.
  – messageGraph.ts: `MessageGraph` class.
  – modelUtils.ts: `getModelFriendlyName`.
  – promptUtils.ts: Global `window` functions for input bar manipulation.
  – textAreaUtils.ts: `getCursorPosition`.
  – webSocketUtils.ts: `handleWebSocketMessage` and WebSocket event hooks.

▸ src/lib/
  – ThemeManager.ts: Manages UI theming.
  – utils.ts: `cn` utility for class names.

▸ src/ (root)
  – App.tsx: Main application root component.
  – CommandInitializationPlugin.tsx: Handles dynamic command registration based on store changes.
  – index.css: Main stylesheet.
  – main.tsx: Application entry point.

─────────────────────────────
5. FUNCTIONALITY FLOWS AND INTERACTIONS
─────────────────────────────
• **Chat & Conversation:** User input via `InputBar` -> `useChatManagement` sends message (with attachments from `useAttachmentStore` processed by `attachmentUtils`) -> Backend -> WebSocket (`WebSocketService`) receives streaming tokens -> `useStreamTokens` updates -> `ConvView` displays. Full messages update `useConvStore`. `MessageGraph` builds tree for `ConvTreeView`.
• **Appearance & Theming:** `AppearanceTab` uses `useAppearanceManagement` & `useAppearanceStore`. `ThemeManagement` and `ThemeModal` use `useThemeManagement` & `useThemeStore`. `ThemeManager.ts` applies themes by injecting CSS variables.
• **Settings (Models, Providers, MCP Servers):** Settings UIs (e.g., `ModelManagement`) use `useResourceManagement` (which uses `useResourceFactory` and `createApiRequest`) and update respective stores (`useModelStore`, `useMcpServerStore`).
• **Prompts (System & User):** Managed by respective stores and management hooks. Editors (`SystemPromptEditor`, `UserPromptEditor`) and libraries (`SystemPromptLibrary`, `UserPromptLibrary`) provide UI. `useSystemPromptSelection` handles applying system prompts and their associated tools/user prompts/models. User prompts are available as slash commands via `SlashDropdown` and `UserPromptProvider`.
• **Tools & Slash Commands:** `ToolPanel` and `ToolModal` for tool management via `useToolsManagement` and `useToolStore`. Active tools are passed to `sendMessage`. Slash commands in `InputBar` use `SlashDropdown`, `slashItemRegistry`, and providers like `FileNameProvider` (using `useFileSystemStore`) and `UserPromptProvider`.
• **Command System:** `CommandInitializer` and `CommandInitializationPlugin` register commands using `commandRegistry.ts`. `CommandBar` allows execution. `PinnedShortcuts` uses `usePinnedCommandsStore`.
• **Panels & Modals:** `NavigationContainer` uses `PanelManager` and `usePanelStore`. `ModalManager` renders modals based on `useModalStore`. `useConfirmationDialog` and `useFormDialog` provide programmatic modal access.
• **File System & Status:** `ProjectFileWatcherService` (backend) sends updates to `WebSocketService`, which updates `useFileSystemStore` via `handleWebSocketMessage` in `websocketUtils.ts`. `StatusMessage` displays content from `useStatusMessageStore`, updated via WebSockets.

─────────────────────────────
6. CONCLUSION
─────────────────────────────
This application’s architecture is a modern, modular React/TypeScript system. It effectively separates concerns using Zustand for state, custom hooks for reusable logic, and services for API/WebSocket communication and command/event management. The introduction of a unified modal system, robust attachment handling, slash commands, and comprehensive theming capabilities makes it a powerful and flexible AI command center. Data flows primarily from backend services via `apiClient` (Axios) and `WebSocketService` into Zustand stores, which then drive the reactive UI components. The command registry and window event service ensure decoupled yet effective inter-component communication.